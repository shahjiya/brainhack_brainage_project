---
title: "Network_brain_age"
output: html_notebook
date: 2024-10-18
---
This is a script to create and populate the Network BrainAge template (https://centilebrain.org/#/brainAGE) using freesurfer outputs.


Load the necessary libraries

```{r}
library(readxl)
library(openxlsx)
library(stringr)
library(dplyr)
library(readr)
```

Load Files.
Change sex to "Male" or "Female" depending on analysis.

```{r}

this_sex <- "Female"

# Load Developmental Network template and demographic data
template_brainage <- read_excel("~/Data/raw/Network_BrainAGE_template.xlsx")

demographics <- read_tsv("~/Data/raw/study-HBN_desc-participants.tsv")

# Load parcellation files (update path if needed)
parcellations_1000 <- read_csv("~/Data/raw/Schaefer2018_1000Parcels_7Networks_order_wide.csv")

```

Function to clean and standardize subject IDs for the thickness and surface area data

```{r}
# Save the original column names for reference
original_template_column_names <- colnames(template_brainage)

# Step 2: Define function to standardize suffixes or fix known typos
standardize_col_names <- function(df) {
  col_names <- colnames(df)
  
  # Standardize suffixes and known naming issues
  col_names <- str_replace_all(col_names, "ThickAvg", "thickness")
  col_names <- str_replace_all(col_names, "SurfArea", "area")
  
  colnames(df) <- col_names
  return(df)
}

parcellations_1000_renamed <- standardize_col_names(parcellations_1000)

```

Apply the subject_ID cleaning function to thickness and surface area files

```{r}
clean_subject_ids_tsv <- function(df) {
  colnames(df)[1] <- "clean_subject_id"  # Rename the first column
  df <- df %>%
    mutate(clean_subject_id = str_remove(clean_subject_id, "^sub-"))  # Remove "sub-" from start
  return(df)
}

parcellation_1000_clean <- clean_subject_ids_tsv(parcellations_1000_renamed)
```


Use the function to clean the demographic subject ids

```{r}
demographics_df <- demographics %>%
  rename(clean_subject_id = participant_id)

template_df<- template_brainage %>%
  rename(clean_subject_id = SubjectID)
```

First filters for time point because we only want baseline scans (also prevents duplicate subject_IDs in the final output). Then filters for sex and then creates a dataframe with subject Id, age, and sex. 

```{r}

gendered_data <- demographics_df %>%
  filter(sex == this_sex) %>%  # Then filter for sex
  select(clean_subject_id, age, sex)  # Keep subject ID, age, and sex for merging

```

Filter the thickness and area data for female subject IDs -> create function to filter subject_IDs? 

```{r}
gendered_parcellation <- parcellation_1000_clean %>%
  filter(clean_subject_id %in% gendered_data$clean_subject_id)
```

Add the female subject_ID, age, and assigned sex to the template_df and this also ensures that there are enough rows to merge the data. 

```{r}

# Make sure the subject_ids, sex, and age are character data types
template_df$clean_subject_id <- as.character(template_df$clean_subject_id)
template_df$sex <- as.character(template_df$sex)  # Add sex column conversion
template_df$age <- as.character(template_df$age)  # Add age column conversion

# First, check if template_df has rows
if (nrow(template_df) == 0) {
  # Create an empty data frame with the same structure as template_df but add the subject IDs and age
  # Keep all the original columns, but add the new data
  template_df <- template_df[0, ]  # Retain column structure but no rows
  
  # Now create a new data frame that only updates clean_subject_id and AGE
  new_data <- data.frame(clean_subject_id =gendered_data$clean_subject_id,
                         age = gendered_data$age,
                         sex = gendered_data$sex,
                         stringsAsFactors = FALSE)
  
  # Make them the same data type
  new_data$clean_subject_id <- as.character(new_data$clean_subject_id)
  new_data$sex <- as.character(new_data$sex)
  new_data$age <- as.character(new_data$age)
  
  # Bind the new data to the empty template, ensuring columns remain intact
  template_df <- bind_rows(template_df, new_data)
} else {
  
  # If template_df already has rows, just update clean_subject_id and AGE columns
  template_df$clean_subject_id <- gendered_data$clean_subject_id
  template_df$age <- gendered_data$age
}

```

Add the default values for the SITE (1 because they were all taken at the same site on the same scanner), ScannerType, and FreeSurfer_Version. Change values if needed. 

```{r}

# Create a named list of default values for columns with missing data
default_values <- list(
  SITE = "1",
  ScannerType = "3",
  FreeSurfer_Version = "7.0"
)

# Update existing columns with default values if they are NA
for (col in names(default_values)) {
  if (col %in% names(template_df)) {
    template_df[[col]] <- ifelse(is.na(template_df[[col]]), default_values[[col]], template_df[[col]])
  }
}

```


Check if subject IDs from both dataframes match

```{r}
common_ids <- intersect(template_df$clean_subject_id, gendered_parcellation$clean_subject_id)
print(paste("Number of matching subject IDs:", length(common_ids)))
```

Make all of the logical variables into characters

```{r}

# Convert all columns in the template_df to characters
template_df <- template_df %>%
  mutate(across(everything(), as.character))

gendered_parcellation <- gendered_parcellation %>%
  mutate(across(everything(), as.character))

```

Populate the template with female subject data and only keep the column names that are in the template. Remove any rows with NA, the calculator will not work if there are any NA values. Then revert back to the original column names. 
Ensure that all the relevant data is properly merged.

```{r}
final_template <- left_join(template_df[, c(1, 2, 3, 4, 5, 6)], gendered_parcellation, by = "clean_subject_id") 

# Select only the columns from template_df
final_template <- final_template %>%
  select(names(template_df))  # Keeps only the columns in template_df  

#remove columns with NA
final_template <- final_template %>%
  filter(!is.na(final_template[[7]]))


```

Change all the data types to numeric and remove the first column of the subject ids because that was not in the original template. Make sure all the data types are numeric because the calculator will not work if they are different data types. 

```{r}

# Convert all other rows and columns to numeric
numeric_data <- final_template %>%
  mutate_at(vars(-2, -4), ~ as.numeric(as.character(.)))

```

The Network brain age only accepts 150 participants at a time so multiple files need to be created to only have 150 participants per file. Output files in parts and then put them through the brain age calculator. 

```{r}

# Number of participants per file (excluding the header)
participants_per_file <- 150

# Calculate how many files you need
num_files <- ceiling(nrow(numeric_data) / participants_per_file)

# Loop through the dataframe, slice into 150 participant chunks, and save each chunk
for (i in 1:num_files) {
  # Slice rows for participants
  start_row <- (i-1)*participants_per_file + 1
  end_row <- min(i*participants_per_file, nrow(numeric_data)) 
  
  chunked_participants <- numeric_data %>%
    slice(start_row:end_row)
  
  # Create file name for each chunk
  file_name <- paste0("~/Data/processed/", tolower(this_sex), "_network_template_part_", i, ".xlsx")
  
  # Write the chunk to an Excel file, keeping the header row
  write.xlsx(chunked_participants, file_name)
  
  # Print a message for each file creation
  print(paste("Saved file:", file_name))
}


```

