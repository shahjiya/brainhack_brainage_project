---
title: "Developmental_brain_age"
output: html_notebook
date: 2024-10-17
---
# Overview
This is a script to create the Developmental BrainAge template (https://centilebrain.org/#/brainAGE) using freesurfer outputs.
**Please follow each step and modify the paths and options as needed.**

---

# Load the necessary libraries

```{r}
library(readxl)
library(openxlsx)
library(stringr)
library(dplyr)
library(readr)
```

# Load Files
# Change sex to "Male" or "Female" depending on analysis.

# Filter for Sex ('Male' or 'Female')

```{r}
sex <- "Female"
```

```{r}

# Load Developmental BrainAGE template and demographic data
template_brainage <- read_excel("~/Data/raw/template_brainage.xlsx")
demographics <- read_tsv("~/Data/raw/study-HBN_desc-participants.tsv")

# Load parcellation files (update path if needed)
parcellations_400 <- read_csv("~/Data/raw/Schaefer2018_400Parcels_7Networks_order_wide.csv")
```

# Clean column names to match the Centile BrainAGE template.
# 1. Saves original column names for reference
# 2. Removes underscores from column names
# 3. Removes first n characters. The length of the columns are checked because some column names have fewer characters and thus if they are removed, it will result in empty column headers. 


# Rename columns in the thickness data from "thickness" to "thick" to match the column names in the template

```{r}
# Save the original column names for reference
original_template_column_names <- colnames(template_brainage)

# Step 1: Define function to clean raw column names
clean_columns <- function(df) {
  if (is.data.frame(df) && ncol(df) > 0) {
    
    # Remove all underscores
    colnames(df) <- str_replace_all(colnames(df), "_", "")
    
    # Remove prefix 'X', 'lh', or 'rh' from beginning of column names
    colnames(df) <- str_replace(colnames(df), "^(lh|rh)", "")
  }
  return(df)
}

# Step 2: Define function to standardize suffixes or fix known typos
standardize_col_names <- function(df) {
  col_names <- colnames(df)
  
  # Standardize suffixes and known naming issues
  col_names <- str_replace_all(col_names, "ThickAvg", "thick")
  col_names <- str_replace_all(col_names, "SurfArea", "area")
  
  colnames(df) <- col_names
  return(df)
}

# Step 3: Clean and rename column names in correct order

# Clean initial names (remove underscores, prefixes)
parcellation_400_clean <- clean_columns(parcellations_400)

# Ensure column names are unique (avoids mutate() errors later)
colnames(parcellation_400_clean) <- make.names(colnames(parcellation_400_clean), unique = TRUE)

# Apply standard renaming (thick -> thick, surf -> area, etc.)
parcellation_400_renamed <- standardize_col_names(parcellation_400_clean)

# Also clean the template file if needed
template_renamed <- clean_columns(template_brainage)

```

```{r}
clean_subject_ids_tsv <- function(df) {
  colnames(df)[1] <- "clean_subject_id"  # Rename the first column
  df <- df %>%
    mutate(clean_subject_id = str_remove(clean_subject_id, "^sub-"))  # Remove "sub-" from start
  return(df)
}

parcellation_400_newid <- clean_subject_ids_tsv(parcellation_400_renamed)
```


# Add clean_subject Id column to the template. Remember to remove it at the end of the code

```{r}
template_renamed$clean_subject_id <- character(0)
demographics_df <- demographics %>%
  rename(clean_subject_id = participant_id)
```

# Filter the dataset to keep only baseline scans (time_point == "01") to avoid duplicate subject_IDs in the final output. 
#Then filter for sex and create a dataframe with just subject Id, age, and sex. 

```{r}

gendered_data <- demographics_df %>%
  filter(sex == "Female") %>%  # Then filter for sex
  select(clean_subject_id, age, sex)  # Keep subject ID, age, and sex for merging

```

# Filter thickness and area data for female subject IDs
# Consider creating a function to filter subject_IDs

```{r}
gendered_parcellation <- parcellation_400_newid %>%
  filter(clean_subject_id %in% gendered_data$clean_subject_id)
```

# Ensure that all columns remain intact while adding the female data

```{r}

#Make sure the the subject_ids are character data types
template_renamed$clean_subject_id <-as.character(template_renamed$clean_subject_id)

# First, check if template_df has rows
if (nrow(template_renamed) == 0) {
  # Create an empty data frame with the same structure as template_df but add the subject IDs and age
  # Keep all the original columns, but add the new data
  template_renamed <- template_renamed[0, ]  # Retain column structure but no rows
  
  # Now create a new data frame that only updates clean_subject_id and AGE
  new_data <- data.frame(clean_subject_id =gendered_data$clean_subject_id,
                         AGE = gendered_data$age,
                         stringsAsFactors = FALSE)
  
  # Bind the new data to the empty template, ensuring columns remain intact
  template_renamed <- bind_rows(template_renamed, new_data)
} else {
  # If template_df already has rows, just update clean_subject_id and AGE columns
  template_renamed$clean_subject_id <- gendered_data$clean_subject_id
  template_renamed$AGE <- gendered_data$age
}

```


# Check if subject IDs from both dataframes match

```{r}
  common_ids <- intersect(template_renamed$clean_subject_id, gendered_parcellation$clean_subject_id)
print(paste("Number of matching subject IDs:", length(common_ids)))
```

# Make all of the logical variables into characters

```{r}

# Convert all columns in the template_df to characters
template_renamed <- template_renamed %>%
  mutate(across(everything(), as.character))

gendered_parcellation <- gendered_parcellation %>%
  mutate(across(everything(), as.character))
```

# Populate the template with female subject data and only keep the column names that are in the template. 
#Remove any rows with NA, the calculator will not work if there are any NA values. Then revert back to the original column names. 
#Ensure that all the relevant data is properly merged.

```{r}
final_template <- left_join(template_renamed[, c(1, 802)], gendered_parcellation, by = "clean_subject_id") 

# Select only the columns from template_df
final_template <- final_template %>%
  select(names(template_renamed))  # Keeps only the columns in templa5te_df  

# Remove columns with NA
final_template <- final_template %>%
  filter(!is.na(final_template[[3]]))

# Revert back to original column names found in the template
colnames(final_template)[1:length(original_template_column_names)] <- original_template_column_names
```

# Output a .csv file that contains the subject ID and the age so that they can be used for the analysis after

```{r}
output_csv_file <- paste0("~/Data/processed/", tolower(sex), "_subID_developmental_template.csv")
write.csv(final_template, file = output_csv_file, row.names = FALSE)
```


# Change all the data types to numeric and remove the first column of the subject ids because that was not in the original template. 
#Make sure all the data types are numeric because the calculator will not work if they are different data types. 

```{r}

final_template <- final_template %>% select(-clean_subject_id)

# Convert all other rows and columns to numeric, starting from row 2 and column 2
numeric_data <- final_template %>%
  mutate_all(~suppressWarnings(as.numeric(as.character(.))))

```

# Save the final populated template into a new Excel file

```{r}

output_file <- paste0("~/Data/processed/", tolower(sex), "_populated_developmental_template.xlsx")
write.xlsx(numeric_data, output_file)

print(paste("Template has been populated and saved as", output_file))
```

